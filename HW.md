# Задание 1.1
## Сравнение ORB и SIFT
### По логам
ORB в отличае от SIFT:
1. находит больше точек 
2. заметно быстрее ищет точки 
3. в разы больше средняя ошибка (только в тестах: Scale50, Scale70, Rotate30Scale75, HerzJesu19RotateM40 -- это не так, то есть в 4/22 тестов)
4. но у них почти одинаковые соотношения масштабов (и практически всегда довольно близкие к 1, за исключением теста Scale200, там у [SIFTOCV] в 2 раза отличаются масштабы)
5. меньше разница углов в тестах Moved, но при этом она заметно больше в тестах, где есть Rotate, и она примерно у них равна на тестах Scale 
6. расстояние между дескрипторами в разы меньше
### По картинкам
У ORB в отличае от SIFT:
1. точки менее равномерно распределены по картинке, они более скученнные в определённых местах 
2. на картинках кажется, что точек меньше, возможно, из-за пункта 1 
3. меньше внимания уделяется фону 
4. точки имеют большую окрестность

# Идеи и мысли
Когда писала часть про экстремумы, задумалась, что лучше: строгие экстремумы или нет? Возможно, мы это обсуждали, но я не помню. Просто нестрогих будет много в одном месте, но они могут пропасть, если их не учесть. Наверно, страшнее потерять такие классные точки (это может быть важное пятно), но при этом это может быть однородный фон, зачем он нам нужен. Думаю, строгие мне больше нравятся

# Ответы на вопросы

**1. Почему SIFT менее точно угадывает средний угол отклонения? изменяется ли ситуация если выкрутить параметр ORIENTATION_VOTES_PEAK_RATIO=0.999? почему?**

Вообще, кажется, что он наоборот более точно угадывает угол отклонения, тем более в тестах на повороты (например, в тесте Rotate45 средняя разница между углами у ORB -- 40.7936 degrees, а у SIFT -- 21.2252 degrees, в 2 раза меньше). В ORB всё происходит так: 

>Вычисляется угол ориентации особой точки. Для этого, сначала вычисляются моменты яркости для окрестности особой точки, и затем угол ориентации особой точки

А в SIFT мы более комплексно подходим к этому, делим на области, учитываем голоса (а ещё помню, мы говорили о том, что яркость не сильно хороший показатель, к примеру, из-за освещения)

При ORIENTATION_VOTES_PEAK_RATIO=0.999 в данных тестах ничего не поменялось. Но, думаю, в общем случае это ухудшение в плане точности, так как рассмотрим меньше направлений для каждой точки. Но при этом нам меньше придётся сравнивать точек, что ускорит время работы. Конкретно здесь мне кажется, что точность, которая будет при 0.8 куда более важна, чем такое ускорение.

**2. Как надежно замерить во сколько раз распараллеливание через OpenMP ускоряет ваш вариант SIFT? Попробуйте сделать это на вашем компьютере, какое ускорение относительно однопоточной версии оказалось? Сколько у вашего процессора ядер и сколько потоков?**

Ничего круче, чем запустить и сравнить время, у меня не получилось придумать

**3. Правда ли можно строить каждый слой в Gaussian пирамиде из самого первого слоя этой октавы? Или нужно обязательно делать так как предложено в статье - дополняя размытие предыдущего слоя этой октавы? Совпадают ли пирамиды визуально?**

Я не заметила особой разницы, думаю, можно

**4. Какие ожидания от картинок в Gaussian пирамиде можно придумать? Как проверить что работает корректно? С какой другой картинкой предыдущей октавы должна визуально совпадать конкретная картинка конкретной октавы? Как их визуально сравнить, ведь они разного размера?**

В коде был подобный вопрос

**5) Почему в октаве Gaussian пирамиды s+3 картинки а не s+2 например?**

В коде был подобный вопрос

**6) Какие ожидания от картинок в DoG пирамиде можно придумать?**

Думаю, хотелось бы прям видеть локальные экстремумы

**7) Почему порог контрастности должен уменьшаться при увеличении числа слоев в октаве?**

Если слоёв мало, то изменения будут более яркими, чем больше, тем изменения плавнее. Так что если не будет уменьшать порог, можем слишком много отфильтровывать, тем самым теряя информацию. Значит порог линейно зависит от размытия между слоями. Про линейность зависимости от числа слоёв:

```
sigmaPrev = INITIAL_IMG_SIGMA * pow(2.0, octave) * pow(k, layer-1);
sigmaCur = INITIAL_IMG_SIGMA * pow(2.0, octave) * pow(k, layer);
k = pow(2.0, 1.0 / OCTAVE_NLAYERS);
```

Значит:

```
sigmaPrev = INITIAL_IMG_SIGMA * pow(2.0, octave) * pow(2.0, (layer-1) / OCTAVE_NLAYERS);
sigmaCur = INITIAL_IMG_SIGMA * pow(2.0, octave) * pow(2.0, layer / OCTAVE_NLAYERS);
```

То есть степень размытия между слоями отличается в pow(2.0, -1 / OCTAVE_NLAYERS) раз.

Пусть увеличили число слоёв в t раз, тогда:

```
sigmaPrev = INITIAL_IMG_SIGMA * pow(2.0, octave) * pow(2.0, (layer-1) / (t * OCTAVE_NLAYERS));
sigmaCur = INITIAL_IMG_SIGMA * pow(2.0, octave) * pow(2.0, layer / (t * OCTAVE_NLAYERS));
```

То есть степень размытия между слоями отличается в pow(2.0, -1 / (t * OCTAVE_NLAYERS)) раз.

Значит степень размытости между слоями при увеличении слоёв изменилась в pow(2.0, (t - 1) / (t * OCTAVE_NLAYERS)) раз. Это не очень похоже на линейную зависимость (так что, возможно, что мои рассуждения не верны), но при небольших t (а мы вряд ли будем увеличивать число слоёв в какое-то огромного количество раз), вполне можно подобрать константу так, чтоб порог изменялся линейно от числа слоёв с достаточной точностью.

**8) Какая строка ответственна за определение сигмы (или что почти то же самое - радиуса) которая задает окрестность по которой определяется ориентация ключевой точки?**


**9) За какой строки вашего кода дескриптор инвариантен к повороту картинки?**
